# 추가 - 테스트와 영속성 컨텍스트
- 테스트 코드에서 영속성 컨텍스트를 쓰면 편한 부분이 있다.
  - 상황
    - saveUserAndLoanTwoBooks 메서드 참고
      - 테스트 코드 자체는 트랜잭션 환경도 아니고, 영속성 컨텍스트가 존재하지 않는다.
        - 지연 초기화 불가능 예외
      - 해결 방법
        1. 테스트 코드에 @Transactional을 붙여준다. (강사는 선호하지 않는 방법 / 토비님, 영한님은 추천)
          - 장점
            - 간결하다
            - 롤백도 된다.
            - 트랜잭션 별 테스트 격리 가능
            - 병렬 테스트 가능
          - 단점
            - 테스트 내성이 떨어진다.
              - 트랜잭션이 있어야만 실행이 가능한 테스트
                - 테스트 코드 내 @Transactional 있지만, 실제 사용 메서드에 @Transactional 없는 경우
                  - 테스트는 성공하지만, 실제 메서드에서 테스트로 실패를 잡아내지 못한다.
            - 트랜잭션 쓰는 장점이, 쓰지 않는 단점보다 강력
          - @Transactional을 테스트 코드에 안 붙이는 경우
            - CleaningSpringBootTest 클린 테스트 클래스를 만들어 상속받도록해서 사용 할 수도 있다.
        2. 1:N 관계에서 N쪽 repository를 활용한다.
           - 장점
             - 테스트 코드에 @Transactional을 안 붙여도 된다.
           - 단점
             - N쪽 repository 의존성을 가져와서 사용해야 할 수도 있다.
        3. fetch Join으로 데이터를 미리 불러온다.
           - 장점
             - 테스트 코드가 깔끔해진다.
           - 단점
             - fetchJoin은 하나만 쓸 수 있다.
               - User(1) - (N) UserLoanHistory
               - User(1) - (N) UserPrivacy
               - fetch join을 각각 쓰거나, 하나의 N에 대해서만 fetch join만 가능하다.
        4. TxHelper를 이용한다.
           - TxHelper 클래스 참고
             - 특정 code block을 트랜잭션이 걸려있는 상태에서 실행할 수 있다.
           - 장점
             - 코드 간결
             - 테스트 내성을 지키고, 테스트와 프러덕션을 정확히 구분
           - 단점
             - 의존성 추가와 메서드 호출을 통한 들여쓰는 방식 필요
- 절대적으로 옳은 방법은 존재하지 않다. 상황과 팀 컨벤션을 준수하자.