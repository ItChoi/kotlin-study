# 4강. 선언 지점 변성 / 사용 지점 변성

## 함수 선언시 변성 부여 방법
- in 또는 out 사용

## 변성 부여 응용을 통해 변성 사용 가능
- 상위 타입 변수에 하위 타입 변수 넣기

## Java 와일드 카드 타입과 대응!
- in, out
```text
- Java 
  - List<? extends Number (상위 클래스)
    - List<Integer (하위 클래스)
- kotlin
  - <out T> = <? extends T>
  - <in T> = <? super T>
```

## 제네릭 클래스 자체를 공변하게 만들 수 있을까?
- out을 사용하지 않고!
  - 코틀린에서 클래스간 변성을 주는 것이 가능
- 제네릭 클래스의 클래스 레벨에서 out 또는 in을 붙여주면 된다.
  - out 생산만 가능(조회), 소비자 역할 불가 (put, ...)
  - in 소비만 가능(조회), 생산자 역할 불가 (put, ...)

## 변성 위치
- 클래스
  - declaration-site variance
  - 자바에 존재하지 않는 방식
- 함수 또는 변수 지점
  - use-site variance (사용 할 때만 변성 부여)
  - java의 와일드 카드 방식

## 선언 지점 변성 활용 예시
- 코틀린 표준 라이브러리에서는 어떻게 활용?
  - Comparable<in T>
    - 데이터를 받고만 있다.
    - in을 통해 클래스 자체가 반공변하게 만들었다.
  - List<out E> : Collection<E>
    - out -> 자바 List랑은 다르다
    - 공변하게 만들더라도 데이터를 꺼낼 수만 있으니 인터페이스 자체에 out 변성을 줬다.
- 데이터를 생산만 하거나 소비만 하는 클래스 자체는 흔하지 않다.
  - in, out을 붙였더라도 @UnsafeVariance를 사용 할 수 있다.
    - out 변성 -> 타입 안정한 소비 가능
    - in 변성 -> 타입 안정한 생산 가능